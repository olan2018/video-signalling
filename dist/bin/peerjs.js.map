{"mappings":"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","sources":["<anon>","bin/peerjs.ts","src/index.ts","src/config/index.ts","src/instance.ts","src/models/realm.ts","src/models/messageQueue.ts","src/services/checkBrokenConnections/index.ts","src/services/messagesExpire/index.ts","src/enums.ts","src/services/webSocketServer/index.ts","src/models/client.ts","src/messageHandler/index.ts","src/messageHandler/handlers/index.ts","src/messageHandler/handlers/heartbeat/index.ts","src/messageHandler/handlers/transmission/index.ts","src/messageHandler/handlersRegistry.ts","src/api/index.ts","app.json","src/api/v1/public/index.ts"],"sourcesContent":["#!/usr/bin/env node\nimport $7BbP7$nodepath from \"node:path\";\nimport $7BbP7$nodefs from \"node:fs\";\nimport $7BbP7$yargs from \"yargs\";\nimport {hideBin as $7BbP7$hideBin} from \"yargs/helpers\";\nimport $7BbP7$express from \"express\";\nimport $7BbP7$nodehttp from \"node:http\";\nimport $7BbP7$nodehttps from \"node:https\";\nimport {randomUUID as $7BbP7$randomUUID} from \"node:crypto\";\nimport {EventEmitter as $7BbP7$EventEmitter} from \"node:events\";\nimport {WebSocketServer as $7BbP7$WebSocketServer} from \"ws\";\nimport $7BbP7$cors from \"cors\";\n\n\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n\n\n\n\n\n\n\nconst $aeb1147dec1b7a02$var$defaultConfig = {\n    host: \"::\",\n    port: 9000,\n    expire_timeout: 5000,\n    alive_timeout: 90000,\n    key: \"peerjs\",\n    path: \"/\",\n    concurrent_limit: 5000,\n    allow_discovery: false,\n    proxied: false,\n    cleanup_out_msgs: 1000,\n    corsOptions: {\n        origin: true\n    }\n};\nvar $aeb1147dec1b7a02$export$2e2bcd8739ae039 = $aeb1147dec1b7a02$var$defaultConfig;\n\n\n\nclass $2c42eaf0ccc66758$export$eb4c623330d4cbcc {\n    getLastReadAt() {\n        return this.lastReadAt;\n    }\n    addMessage(message) {\n        this.messages.push(message);\n    }\n    readMessage() {\n        if (this.messages.length > 0) {\n            this.lastReadAt = new Date().getTime();\n            return this.messages.shift();\n        }\n        return undefined;\n    }\n    getMessages() {\n        return this.messages;\n    }\n    constructor(){\n        this.lastReadAt = new Date().getTime();\n        this.messages = [];\n    }\n}\n\n\n\nclass $0a339ca52e0451c9$export$3ee29d34e33d9116 {\n    getClientsIds() {\n        return [\n            ...this.clients.keys()\n        ];\n    }\n    getClientById(clientId) {\n        return this.clients.get(clientId);\n    }\n    getClientsIdsWithQueue() {\n        return [\n            ...this.messageQueues.keys()\n        ];\n    }\n    setClient(client, id) {\n        this.clients.set(id, client);\n    }\n    removeClientById(id) {\n        const client = this.getClientById(id);\n        if (!client) return false;\n        this.clients.delete(id);\n        return true;\n    }\n    getMessageQueueById(id) {\n        return this.messageQueues.get(id);\n    }\n    addMessageToQueue(id, message) {\n        if (!this.getMessageQueueById(id)) this.messageQueues.set(id, new (0, $2c42eaf0ccc66758$export$eb4c623330d4cbcc)());\n        this.getMessageQueueById(id)?.addMessage(message);\n    }\n    clearMessageQueue(id) {\n        this.messageQueues.delete(id);\n    }\n    generateClientId(generateClientId) {\n        const generateId = generateClientId ? generateClientId : (0, $7BbP7$randomUUID);\n        let clientId = generateId();\n        while(this.getClientById(clientId))clientId = generateId();\n        return clientId;\n    }\n    constructor(){\n        this.clients = new Map();\n        this.messageQueues = new Map();\n    }\n}\n\n\nconst $6840aafc61c9abd6$var$DEFAULT_CHECK_INTERVAL = 300;\nclass $6840aafc61c9abd6$export$6fa53df6b5b88df7 {\n    constructor({ realm: realm, config: config, checkInterval: checkInterval = $6840aafc61c9abd6$var$DEFAULT_CHECK_INTERVAL, onClose: onClose }){\n        this.timeoutId = null;\n        this.realm = realm;\n        this.config = config;\n        this.onClose = onClose;\n        this.checkInterval = checkInterval;\n    }\n    start() {\n        if (this.timeoutId) clearTimeout(this.timeoutId);\n        this.timeoutId = setTimeout(()=>{\n            this.checkConnections();\n            this.timeoutId = null;\n            this.start();\n        }, this.checkInterval);\n    }\n    stop() {\n        if (this.timeoutId) {\n            clearTimeout(this.timeoutId);\n            this.timeoutId = null;\n        }\n    }\n    checkConnections() {\n        const clientsIds = this.realm.getClientsIds();\n        const now = new Date().getTime();\n        const { alive_timeout: aliveTimeout } = this.config;\n        for (const clientId of clientsIds){\n            const client = this.realm.getClientById(clientId);\n            if (!client) continue;\n            const timeSinceLastPing = now - client.getLastPing();\n            if (timeSinceLastPing < aliveTimeout) continue;\n            try {\n                client.getSocket()?.close();\n            } finally{\n                this.realm.clearMessageQueue(clientId);\n                this.realm.removeClientById(clientId);\n                client.setSocket(null);\n                this.onClose?.(client);\n            }\n        }\n    }\n}\n\n\nvar $d461d7260b6fc353$export$b8e9cd941e8016ac;\n(function(Errors) {\n    Errors[\"INVALID_KEY\"] = \"Invalid key provided\";\n    Errors[\"INVALID_TOKEN\"] = \"Invalid token provided\";\n    Errors[\"INVALID_WS_PARAMETERS\"] = \"No id, token, or key supplied to websocket server\";\n    Errors[\"CONNECTION_LIMIT_EXCEED\"] = \"Server has reached its concurrent user limit\";\n})($d461d7260b6fc353$export$b8e9cd941e8016ac || ($d461d7260b6fc353$export$b8e9cd941e8016ac = {}));\nvar $d461d7260b6fc353$export$80edbf15fa61a4db;\n(function(MessageType) {\n    MessageType[\"OPEN\"] = \"OPEN\";\n    MessageType[\"LEAVE\"] = \"LEAVE\";\n    MessageType[\"CANDIDATE\"] = \"CANDIDATE\";\n    MessageType[\"OFFER\"] = \"OFFER\";\n    MessageType[\"ANSWER\"] = \"ANSWER\";\n    MessageType[\"EXPIRE\"] = \"EXPIRE\";\n    MessageType[\"HEARTBEAT\"] = \"HEARTBEAT\";\n    MessageType[\"ID_TAKEN\"] = \"ID-TAKEN\";\n    MessageType[\"ERROR\"] = \"ERROR\";\n})($d461d7260b6fc353$export$80edbf15fa61a4db || ($d461d7260b6fc353$export$80edbf15fa61a4db = {}));\n\n\nclass $c97baf9b78981954$export$a13b411d0e88b1af {\n    constructor({ realm: realm, config: config, messageHandler: messageHandler }){\n        this.timeoutId = null;\n        this.realm = realm;\n        this.config = config;\n        this.messageHandler = messageHandler;\n    }\n    startMessagesExpiration() {\n        if (this.timeoutId) clearTimeout(this.timeoutId);\n        // Clean up outstanding messages\n        this.timeoutId = setTimeout(()=>{\n            this.pruneOutstanding();\n            this.timeoutId = null;\n            this.startMessagesExpiration();\n        }, this.config.cleanup_out_msgs);\n    }\n    stopMessagesExpiration() {\n        if (this.timeoutId) {\n            clearTimeout(this.timeoutId);\n            this.timeoutId = null;\n        }\n    }\n    pruneOutstanding() {\n        const destinationClientsIds = this.realm.getClientsIdsWithQueue();\n        const now = new Date().getTime();\n        const maxDiff = this.config.expire_timeout;\n        const seen = {};\n        for (const destinationClientId of destinationClientsIds){\n            const messageQueue = this.realm.getMessageQueueById(destinationClientId);\n            if (!messageQueue) continue;\n            const lastReadDiff = now - messageQueue.getLastReadAt();\n            if (lastReadDiff < maxDiff) continue;\n            const messages = messageQueue.getMessages();\n            for (const message of messages){\n                const seenKey = `${message.src}_${message.dst}`;\n                if (!seen[seenKey]) {\n                    this.messageHandler.handle(undefined, {\n                        type: (0, $d461d7260b6fc353$export$80edbf15fa61a4db).EXPIRE,\n                        src: message.dst,\n                        dst: message.src\n                    });\n                    seen[seenKey] = true;\n                }\n            }\n            this.realm.clearMessageQueue(destinationClientId);\n        }\n    }\n}\n\n\n\n\nclass $d09fcb6ab78a3f48$export$1f2bb630327ac4b6 {\n    constructor({ id: id, token: token }){\n        this.socket = null;\n        this.lastPing = new Date().getTime();\n        this.id = id;\n        this.token = token;\n    }\n    getId() {\n        return this.id;\n    }\n    getToken() {\n        return this.token;\n    }\n    getSocket() {\n        return this.socket;\n    }\n    setSocket(socket) {\n        this.socket = socket;\n    }\n    getLastPing() {\n        return this.lastPing;\n    }\n    setLastPing(lastPing) {\n        this.lastPing = lastPing;\n    }\n    send(data) {\n        this.socket?.send(JSON.stringify(data));\n    }\n}\n\n\n\nconst $4ae24f8b3b7cf7b0$var$WS_PATH = \"peerjs\";\nclass $4ae24f8b3b7cf7b0$export$f47674b57e51ee3b extends (0, $7BbP7$EventEmitter) {\n    constructor({ server: server, realm: realm, config: config }){\n        super();\n        this.setMaxListeners(0);\n        this.realm = realm;\n        this.config = config;\n        const path = this.config.path;\n        this.path = `${path}${path.endsWith(\"/\") ? \"\" : \"/\"}${$4ae24f8b3b7cf7b0$var$WS_PATH}`;\n        const options = {\n            path: this.path,\n            server: server\n        };\n        this.socketServer = config.createWebSocketServer ? config.createWebSocketServer(options) : new (0, $7BbP7$WebSocketServer)(options);\n        this.socketServer.on(\"connection\", (socket, req)=>{\n            this._onSocketConnection(socket, req);\n        });\n        this.socketServer.on(\"error\", (error)=>{\n            this._onSocketError(error);\n        });\n    }\n    _onSocketConnection(socket, req) {\n        // An unhandled socket error might crash the server. Handle it first.\n        socket.on(\"error\", (error)=>{\n            this._onSocketError(error);\n        });\n        // We are only interested in the query, the base url is therefore not relevant\n        const { searchParams: searchParams } = new URL(req.url ?? \"\", \"https://peerjs\");\n        const { id: id, token: token, key: key } = Object.fromEntries(searchParams.entries());\n        if (!id || !token || !key) {\n            this._sendErrorAndClose(socket, (0, $d461d7260b6fc353$export$b8e9cd941e8016ac).INVALID_WS_PARAMETERS);\n            return;\n        }\n        if (key !== this.config.key) {\n            this._sendErrorAndClose(socket, (0, $d461d7260b6fc353$export$b8e9cd941e8016ac).INVALID_KEY);\n            return;\n        }\n        const client = this.realm.getClientById(id);\n        if (client) {\n            if (token !== client.getToken()) {\n                // ID-taken, invalid token\n                socket.send(JSON.stringify({\n                    type: (0, $d461d7260b6fc353$export$80edbf15fa61a4db).ID_TAKEN,\n                    payload: {\n                        msg: \"ID is taken\"\n                    }\n                }));\n                socket.close();\n                return;\n            }\n            this._configureWS(socket, client);\n            return;\n        }\n        this._registerClient({\n            socket: socket,\n            id: id,\n            token: token\n        });\n    }\n    _onSocketError(error) {\n        // handle error\n        this.emit(\"error\", error);\n    }\n    _registerClient({ socket: socket, id: id, token: token }) {\n        // Check concurrent limit\n        const clientsCount = this.realm.getClientsIds().length;\n        if (clientsCount >= this.config.concurrent_limit) {\n            this._sendErrorAndClose(socket, (0, $d461d7260b6fc353$export$b8e9cd941e8016ac).CONNECTION_LIMIT_EXCEED);\n            return;\n        }\n        const newClient = new (0, $d09fcb6ab78a3f48$export$1f2bb630327ac4b6)({\n            id: id,\n            token: token\n        });\n        this.realm.setClient(newClient, id);\n        socket.send(JSON.stringify({\n            type: (0, $d461d7260b6fc353$export$80edbf15fa61a4db).OPEN\n        }));\n        this._configureWS(socket, newClient);\n    }\n    _configureWS(socket, client) {\n        client.setSocket(socket);\n        // Cleanup after a socket closes.\n        socket.on(\"close\", ()=>{\n            if (client.getSocket() === socket) {\n                this.realm.removeClientById(client.getId());\n                this.emit(\"close\", client);\n            }\n        });\n        // Handle messages from peers.\n        socket.on(\"message\", (data)=>{\n            try {\n                // eslint-disable-next-line @typescript-eslint/no-base-to-string\n                const message = JSON.parse(data.toString());\n                message.src = client.getId();\n                this.emit(\"message\", client, message);\n            } catch (e) {\n                this.emit(\"error\", e);\n            }\n        });\n        this.emit(\"connection\", client);\n    }\n    _sendErrorAndClose(socket, msg) {\n        socket.send(JSON.stringify({\n            type: (0, $d461d7260b6fc353$export$80edbf15fa61a4db).ERROR,\n            payload: {\n                msg: msg\n            }\n        }));\n        socket.close();\n    }\n}\n\n\n\nconst $c523c19e3fc944a1$export$65302b915833a46d = (client)=>{\n    if (client) {\n        const nowTime = new Date().getTime();\n        client.setLastPing(nowTime);\n    }\n    return true;\n};\n\n\n\nconst $879e80f95ec634eb$export$809c011ea942310 = ({ realm: realm })=>{\n    const handle = (client, message)=>{\n        const type = message.type;\n        const srcId = message.src;\n        const dstId = message.dst;\n        const destinationClient = realm.getClientById(dstId);\n        // User is connected!\n        if (destinationClient) {\n            const socket = destinationClient.getSocket();\n            try {\n                if (socket) {\n                    const data = JSON.stringify(message);\n                    socket.send(data);\n                } else // Neither socket no res available. Peer dead?\n                throw new Error(\"Peer dead\");\n            } catch (e) {\n                // This happens when a peer disconnects without closing connections and\n                // the associated WebSocket has not closed.\n                // Tell other side to stop trying.\n                if (socket) socket.close();\n                else realm.removeClientById(destinationClient.getId());\n                handle(client, {\n                    type: (0, $d461d7260b6fc353$export$80edbf15fa61a4db).LEAVE,\n                    src: dstId,\n                    dst: srcId\n                });\n            }\n        } else {\n            // Wait for this client to connect/reconnect (XHR) for important\n            // messages.\n            const ignoredTypes = [\n                (0, $d461d7260b6fc353$export$80edbf15fa61a4db).LEAVE,\n                (0, $d461d7260b6fc353$export$80edbf15fa61a4db).EXPIRE\n            ];\n            if (!ignoredTypes.includes(type) && dstId) realm.addMessageToQueue(dstId, message);\n            else if (type === (0, $d461d7260b6fc353$export$80edbf15fa61a4db).LEAVE && !dstId) realm.removeClientById(srcId);\n        }\n        return true;\n    };\n    return handle;\n};\n\n\n\n\nclass $df0509eaca4ae82c$export$cfe4a96645b0bbcf {\n    registerHandler(messageType, handler) {\n        if (this.handlers.has(messageType)) return;\n        this.handlers.set(messageType, handler);\n    }\n    handle(client, message) {\n        const { type: type } = message;\n        const handler = this.handlers.get(type);\n        if (!handler) return false;\n        return handler(client, message);\n    }\n    constructor(){\n        this.handlers = new Map();\n    }\n}\n\n\nclass $3089a9bad51bbb04$export$3deceafe0aaeaa95 {\n    constructor(realm, handlersRegistry = new (0, $df0509eaca4ae82c$export$cfe4a96645b0bbcf)()){\n        this.handlersRegistry = handlersRegistry;\n        const transmissionHandler = (0, $879e80f95ec634eb$export$809c011ea942310)({\n            realm: realm\n        });\n        const heartbeatHandler = (0, $c523c19e3fc944a1$export$65302b915833a46d);\n        const handleTransmission = (client, { type: type, src: src, dst: dst, payload: payload })=>{\n            return transmissionHandler(client, {\n                type: type,\n                src: src,\n                dst: dst,\n                payload: payload\n            });\n        };\n        const handleHeartbeat = (client, message)=>heartbeatHandler(client, message);\n        this.handlersRegistry.registerHandler((0, $d461d7260b6fc353$export$80edbf15fa61a4db).HEARTBEAT, handleHeartbeat);\n        this.handlersRegistry.registerHandler((0, $d461d7260b6fc353$export$80edbf15fa61a4db).OFFER, handleTransmission);\n        this.handlersRegistry.registerHandler((0, $d461d7260b6fc353$export$80edbf15fa61a4db).ANSWER, handleTransmission);\n        this.handlersRegistry.registerHandler((0, $d461d7260b6fc353$export$80edbf15fa61a4db).CANDIDATE, handleTransmission);\n        this.handlersRegistry.registerHandler((0, $d461d7260b6fc353$export$80edbf15fa61a4db).LEAVE, handleTransmission);\n        this.handlersRegistry.registerHandler((0, $d461d7260b6fc353$export$80edbf15fa61a4db).EXPIRE, handleTransmission);\n    }\n    handle(client, message) {\n        return this.handlersRegistry.handle(client, message);\n    }\n}\n\n\n\n\nvar $264fdbd7932d14df$exports = {};\n$264fdbd7932d14df$exports = JSON.parse('{\"name\":\"PeerJS Server\",\"description\":\"A server side element to broker connections between PeerJS clients.\",\"website\":\"https://peerjs.com/\"}');\n\n\n\nvar $6910ff2a5db5006f$export$2e2bcd8739ae039 = ({ config: config, realm: realm })=>{\n    const app = (0, $7BbP7$express).Router();\n    // Retrieve guaranteed random ID.\n    app.get(\"/id\", (_, res)=>{\n        res.contentType(\"html\");\n        res.send(realm.generateClientId(config.generateClientId));\n    });\n    // Get a list of all peers for a key, enabled by the `allowDiscovery` flag.\n    app.get(\"/peers\", (_, res)=>{\n        if (config.allow_discovery) {\n            const clientsIds = realm.getClientsIds();\n            return res.send(clientsIds);\n        }\n        return res.sendStatus(401);\n    });\n    return app;\n};\n\n\nconst $69f9994c6ebd6802$export$bf71da7aebe9ddc1 = ({ config: config, realm: realm, corsOptions: corsOptions })=>{\n    const app = (0, $7BbP7$express).Router();\n    app.use((0, $7BbP7$cors)(corsOptions));\n    app.get(\"/\", (_, res)=>{\n        res.send((0, (/*@__PURE__*/$parcel$interopDefault($264fdbd7932d14df$exports))));\n    });\n    app.use(\"/:key\", (0, $6910ff2a5db5006f$export$2e2bcd8739ae039)({\n        config: config,\n        realm: realm\n    }));\n    return app;\n};\n\n\nconst $e7d4fd16baa81890$export$99152e8d49ca4e7d = ({ app: app, server: server, options: options })=>{\n    const config = options;\n    const realm = new (0, $0a339ca52e0451c9$export$3ee29d34e33d9116)();\n    const messageHandler = new (0, $3089a9bad51bbb04$export$3deceafe0aaeaa95)(realm);\n    const api = (0, $69f9994c6ebd6802$export$bf71da7aebe9ddc1)({\n        config: config,\n        realm: realm,\n        corsOptions: options.corsOptions\n    });\n    const messagesExpire = new (0, $c97baf9b78981954$export$a13b411d0e88b1af)({\n        realm: realm,\n        config: config,\n        messageHandler: messageHandler\n    });\n    const checkBrokenConnections = new (0, $6840aafc61c9abd6$export$6fa53df6b5b88df7)({\n        realm: realm,\n        config: config,\n        onClose: (client)=>{\n            app.emit(\"disconnect\", client);\n        }\n    });\n    app.use(options.path, api);\n    //use mountpath for WS server\n    const customConfig = {\n        ...config,\n        path: (0, $7BbP7$nodepath).posix.join(app.path(), options.path, \"/\")\n    };\n    const wss = new (0, $4ae24f8b3b7cf7b0$export$f47674b57e51ee3b)({\n        server: server,\n        realm: realm,\n        config: customConfig\n    });\n    wss.on(\"connection\", (client)=>{\n        const messageQueue = realm.getMessageQueueById(client.getId());\n        if (messageQueue) {\n            let message;\n            while(message = messageQueue.readMessage())messageHandler.handle(client, message);\n            realm.clearMessageQueue(client.getId());\n        }\n        app.emit(\"connection\", client);\n    });\n    wss.on(\"message\", (client, message)=>{\n        app.emit(\"message\", client, message);\n        messageHandler.handle(client, message);\n    });\n    wss.on(\"close\", (client)=>{\n        app.emit(\"disconnect\", client);\n    });\n    wss.on(\"error\", (error)=>{\n        app.emit(\"error\", error);\n    });\n    messagesExpire.startMessagesExpiration();\n    checkBrokenConnections.start();\n};\n\n\nfunction $0fe9c43b5c368182$export$8c57434a18c696c9(server, options) {\n    const app = (0, $7BbP7$express)();\n    const newOptions = {\n        ...(0, $aeb1147dec1b7a02$export$2e2bcd8739ae039),\n        ...options\n    };\n    if (newOptions.proxied) app.set(\"trust proxy\", newOptions.proxied === \"false\" ? false : !!newOptions.proxied);\n    app.on(\"mount\", ()=>{\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (!server) throw new Error(\"Server is not passed to constructor - can't start PeerServer\");\n        (0, $e7d4fd16baa81890$export$99152e8d49ca4e7d)({\n            app: app,\n            server: server,\n            options: newOptions\n        });\n    });\n    return app;\n}\nfunction $0fe9c43b5c368182$export$f99d31af51f48b1e(options = {}, callback) {\n    const app = (0, $7BbP7$express)();\n    let newOptions = {\n        ...(0, $aeb1147dec1b7a02$export$2e2bcd8739ae039),\n        ...options\n    };\n    const port = newOptions.port;\n    const host = newOptions.host;\n    let server;\n    const { ssl: ssl, ...restOptions } = newOptions;\n    if (ssl && Object.keys(ssl).length) {\n        server = (0, $7BbP7$nodehttps).createServer(ssl, app);\n        newOptions = restOptions;\n    } else server = (0, $7BbP7$nodehttp).createServer(app);\n    const peerjs = $0fe9c43b5c368182$export$8c57434a18c696c9(server, newOptions);\n    app.use(peerjs);\n    server.listen(port, host, ()=>callback?.(server));\n    return peerjs;\n}\n\n\nconst $3809f3d53201df9f$var$optimistUsageLength = 98;\nconst $3809f3d53201df9f$var$y = (0, $7BbP7$yargs)((0, $7BbP7$hideBin)(process.argv));\nconst $3809f3d53201df9f$var$portEnvIsSet = !!process.env[\"PORT\"];\nconst $3809f3d53201df9f$var$opts = $3809f3d53201df9f$var$y.usage(\"Usage: $0\").wrap(Math.min($3809f3d53201df9f$var$optimistUsageLength, $3809f3d53201df9f$var$y.terminalWidth())).options({\n    expire_timeout: {\n        demandOption: false,\n        alias: \"t\",\n        describe: \"timeout (milliseconds)\",\n        default: 5000\n    },\n    concurrent_limit: {\n        demandOption: false,\n        alias: \"c\",\n        describe: \"concurrent limit\",\n        default: 5000\n    },\n    alive_timeout: {\n        demandOption: false,\n        describe: \"broken connection check timeout (milliseconds)\",\n        default: 60000\n    },\n    key: {\n        demandOption: false,\n        alias: \"k\",\n        describe: \"connection key\",\n        default: \"peerjs\"\n    },\n    sslkey: {\n        type: \"string\",\n        demandOption: false,\n        describe: \"path to SSL key\"\n    },\n    sslcert: {\n        type: \"string\",\n        demandOption: false,\n        describe: \"path to SSL certificate\"\n    },\n    host: {\n        type: \"string\",\n        demandOption: false,\n        alias: \"H\",\n        describe: \"host\"\n    },\n    port: {\n        type: \"number\",\n        demandOption: !$3809f3d53201df9f$var$portEnvIsSet,\n        alias: \"p\",\n        describe: \"port\"\n    },\n    path: {\n        type: \"string\",\n        demandOption: false,\n        describe: \"custom path\",\n        default: process.env[\"PEERSERVER_PATH\"] ?? \"/\"\n    },\n    allow_discovery: {\n        type: \"boolean\",\n        demandOption: false,\n        describe: \"allow discovery of peers\"\n    },\n    proxied: {\n        type: \"boolean\",\n        demandOption: false,\n        describe: \"Set true if PeerServer stays behind a reverse proxy\",\n        default: false\n    },\n    cors: {\n        type: \"string\",\n        array: true,\n        describe: \"Set the list of CORS origins\"\n    }\n}).boolean(\"allow_discovery\").parseSync();\nif (!$3809f3d53201df9f$var$opts.port) // .port is only not set if the PORT env var is set\n// eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n$3809f3d53201df9f$var$opts.port = parseInt(process.env[\"PORT\"]);\nif ($3809f3d53201df9f$var$opts.cors) $3809f3d53201df9f$var$opts[\"corsOptions\"] = {\n    origin: $3809f3d53201df9f$var$opts.cors\n};\nprocess.on(\"uncaughtException\", function(e) {\n    console.error(\"Error: \" + e.toString());\n});\nif ($3809f3d53201df9f$var$opts.sslkey ?? $3809f3d53201df9f$var$opts.sslcert) {\n    if ($3809f3d53201df9f$var$opts.sslkey && $3809f3d53201df9f$var$opts.sslcert) $3809f3d53201df9f$var$opts[\"ssl\"] = {\n        key: (0, $7BbP7$nodefs).readFileSync((0, $7BbP7$nodepath).resolve($3809f3d53201df9f$var$opts.sslkey)),\n        cert: (0, $7BbP7$nodefs).readFileSync((0, $7BbP7$nodepath).resolve($3809f3d53201df9f$var$opts.sslcert))\n    };\n    else {\n        console.error(\"Warning: PeerServer will not run because either the key or the certificate has not been provided.\");\n        process.exit(1);\n    }\n}\nconst $3809f3d53201df9f$var$userPath = $3809f3d53201df9f$var$opts.path;\nconst $3809f3d53201df9f$var$server = (0, $0fe9c43b5c368182$export$f99d31af51f48b1e)($3809f3d53201df9f$var$opts, (server)=>{\n    const { address: host, port: port } = server.address();\n    console.log(\"Started PeerServer on %s, port: %s, path: %s\", host, port, $3809f3d53201df9f$var$userPath || \"/\");\n    const shutdownApp = ()=>{\n        server.close(()=>{\n            console.log(\"Http server closed.\");\n            process.exit(0);\n        });\n    };\n    process.on(\"SIGINT\", shutdownApp);\n    process.on(\"SIGTERM\", shutdownApp);\n});\n$3809f3d53201df9f$var$server.on(\"connection\", (client)=>{\n    console.log(`Client connected: ${client.getId()}`);\n});\n$3809f3d53201df9f$var$server.on(\"disconnect\", (client)=>{\n    console.log(`Client disconnected: ${client.getId()}`);\n});\n\n\n//# sourceMappingURL=peerjs.js.map\n","#!/usr/bin/env node\n\nimport path from \"node:path\";\nimport fs from \"node:fs\";\nconst optimistUsageLength = 98;\nimport yargs from \"yargs\";\nimport { hideBin } from \"yargs/helpers\";\nimport { PeerServer } from \"../src/index.ts\";\nimport type { AddressInfo } from \"node:net\";\nimport type { CorsOptions } from \"cors\";\n\nconst y = yargs(hideBin(process.argv));\n\nconst portEnvIsSet = !!process.env[\"PORT\"];\n\nconst opts = y\n\t.usage(\"Usage: $0\")\n\t.wrap(Math.min(optimistUsageLength, y.terminalWidth()))\n\t.options({\n\t\texpire_timeout: {\n\t\t\tdemandOption: false,\n\t\t\talias: \"t\",\n\t\t\tdescribe: \"timeout (milliseconds)\",\n\t\t\tdefault: 5000,\n\t\t},\n\t\tconcurrent_limit: {\n\t\t\tdemandOption: false,\n\t\t\talias: \"c\",\n\t\t\tdescribe: \"concurrent limit\",\n\t\t\tdefault: 5000,\n\t\t},\n\t\talive_timeout: {\n\t\t\tdemandOption: false,\n\t\t\tdescribe: \"broken connection check timeout (milliseconds)\",\n\t\t\tdefault: 60000,\n\t\t},\n\t\tkey: {\n\t\t\tdemandOption: false,\n\t\t\talias: \"k\",\n\t\t\tdescribe: \"connection key\",\n\t\t\tdefault: \"peerjs\",\n\t\t},\n\t\tsslkey: {\n\t\t\ttype: \"string\",\n\t\t\tdemandOption: false,\n\t\t\tdescribe: \"path to SSL key\",\n\t\t},\n\t\tsslcert: {\n\t\t\ttype: \"string\",\n\t\t\tdemandOption: false,\n\t\t\tdescribe: \"path to SSL certificate\",\n\t\t},\n\t\thost: {\n\t\t\ttype: \"string\",\n\t\t\tdemandOption: false,\n\t\t\talias: \"H\",\n\t\t\tdescribe: \"host\",\n\t\t},\n\t\tport: {\n\t\t\ttype: \"number\",\n\t\t\tdemandOption: !portEnvIsSet,\n\t\t\talias: \"p\",\n\t\t\tdescribe: \"port\",\n\t\t},\n\t\tpath: {\n\t\t\ttype: \"string\",\n\t\t\tdemandOption: false,\n\t\t\tdescribe: \"custom path\",\n\t\t\tdefault: process.env[\"PEERSERVER_PATH\"] ?? \"/\",\n\t\t},\n\t\tallow_discovery: {\n\t\t\ttype: \"boolean\",\n\t\t\tdemandOption: false,\n\t\t\tdescribe: \"allow discovery of peers\",\n\t\t},\n\t\tproxied: {\n\t\t\ttype: \"boolean\",\n\t\t\tdemandOption: false,\n\t\t\tdescribe: \"Set true if PeerServer stays behind a reverse proxy\",\n\t\t\tdefault: false,\n\t\t},\n\t\tcors: {\n\t\t\ttype: \"string\",\n\t\t\tarray: true,\n\t\t\tdescribe: \"Set the list of CORS origins\",\n\t\t},\n\t})\n\t.boolean(\"allow_discovery\")\n\t.parseSync();\n\nif (!opts.port) {\n\t// .port is only not set if the PORT env var is set\n\t// eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\topts.port = parseInt(process.env[\"PORT\"]!);\n}\nif (opts.cors) {\n\topts[\"corsOptions\"] = {\n\t\torigin: opts.cors,\n\t} satisfies CorsOptions;\n}\nprocess.on(\"uncaughtException\", function (e) {\n\tconsole.error(\"Error: \" + e.toString());\n});\n\nif (opts.sslkey ?? opts.sslcert) {\n\tif (opts.sslkey && opts.sslcert) {\n\t\topts[\"ssl\"] = {\n\t\t\tkey: fs.readFileSync(path.resolve(opts.sslkey)),\n\t\t\tcert: fs.readFileSync(path.resolve(opts.sslcert)),\n\t\t};\n\t} else {\n\t\tconsole.error(\n\t\t\t\"Warning: PeerServer will not run because either \" +\n\t\t\t\t\"the key or the certificate has not been provided.\",\n\t\t);\n\t\tprocess.exit(1);\n\t}\n}\n\nconst userPath = opts.path;\nconst server = PeerServer(opts, (server) => {\n\tconst { address: host, port } = server.address() as AddressInfo;\n\n\tconsole.log(\n\t\t\"Started PeerServer on %s, port: %s, path: %s\",\n\t\thost,\n\t\tport,\n\t\tuserPath || \"/\",\n\t);\n\n\tconst shutdownApp = () => {\n\t\tserver.close(() => {\n\t\t\tconsole.log(\"Http server closed.\");\n\n\t\t\tprocess.exit(0);\n\t\t});\n\t};\n\n\tprocess.on(\"SIGINT\", shutdownApp);\n\tprocess.on(\"SIGTERM\", shutdownApp);\n});\n\nserver.on(\"connection\", (client) => {\n\tconsole.log(`Client connected: ${client.getId()}`);\n});\n\nserver.on(\"disconnect\", (client) => {\n\tconsole.log(`Client disconnected: ${client.getId()}`);\n});\n","import express, { type Express } from \"express\";\nimport http from \"node:http\";\nimport https from \"node:https\";\n\nimport type { IConfig } from \"./config/index.ts\";\nimport defaultConfig from \"./config/index.ts\";\nimport type { PeerServerEvents } from \"./instance.ts\";\nimport { createInstance } from \"./instance.ts\";\nimport type { IClient } from \"./models/client.ts\";\nimport type { IMessage } from \"./models/message.ts\";\n\nexport type { MessageType } from \"./enums.ts\";\nexport type { IConfig, PeerServerEvents, IClient, IMessage };\n\nfunction ExpressPeerServer(\n\tserver: https.Server | http.Server,\n\toptions?: Partial<IConfig>,\n) {\n\tconst app = express();\n\n\tconst newOptions: IConfig = {\n\t\t...defaultConfig,\n\t\t...options,\n\t};\n\n\tif (newOptions.proxied) {\n\t\tapp.set(\n\t\t\t\"trust proxy\",\n\t\t\tnewOptions.proxied === \"false\" ? false : !!newOptions.proxied,\n\t\t);\n\t}\n\n\tapp.on(\"mount\", () => {\n\t\t// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n\t\tif (!server) {\n\t\t\tthrow new Error(\n\t\t\t\t\"Server is not passed to constructor - \" + \"can't start PeerServer\",\n\t\t\t);\n\t\t}\n\n\t\tcreateInstance({ app, server, options: newOptions });\n\t});\n\n\treturn app as Express & PeerServerEvents;\n}\n\nfunction PeerServer(\n\toptions: Partial<IConfig> = {},\n\tcallback?: (server: https.Server | http.Server) => void,\n) {\n\tconst app = express();\n\n\tlet newOptions: IConfig = {\n\t\t...defaultConfig,\n\t\t...options,\n\t};\n\n\tconst port = newOptions.port;\n\tconst host = newOptions.host;\n\n\tlet server: https.Server | http.Server;\n\n\tconst { ssl, ...restOptions } = newOptions;\n\tif (ssl && Object.keys(ssl).length) {\n\t\tserver = https.createServer(ssl, app);\n\n\t\tnewOptions = restOptions;\n\t} else {\n\t\tserver = http.createServer(app);\n\t}\n\n\tconst peerjs = ExpressPeerServer(server, newOptions);\n\tapp.use(peerjs);\n\n\tserver.listen(port, host, () => callback?.(server));\n\n\treturn peerjs;\n}\n\nexport { ExpressPeerServer, PeerServer };\n","import type { WebSocketServer, ServerOptions } from \"ws\";\nimport type { CorsOptions } from \"cors\";\n\nexport interface IConfig {\n\treadonly host: string;\n\treadonly port: number;\n\treadonly expire_timeout: number;\n\treadonly alive_timeout: number;\n\treadonly key: string;\n\treadonly path: string;\n\treadonly concurrent_limit: number;\n\treadonly allow_discovery: boolean;\n\treadonly proxied: boolean | string;\n\treadonly cleanup_out_msgs: number;\n\treadonly ssl?: {\n\t\tkey: string;\n\t\tcert: string;\n\t};\n\treadonly generateClientId?: () => string;\n\treadonly createWebSocketServer?: (options: ServerOptions) => WebSocketServer;\n\treadonly corsOptions: CorsOptions;\n}\n\nconst defaultConfig: IConfig = {\n\thost: \"::\",\n\tport: 9000,\n\texpire_timeout: 5000,\n\talive_timeout: 90000,\n\tkey: \"peerjs\",\n\tpath: \"/\",\n\tconcurrent_limit: 5000,\n\tallow_discovery: false,\n\tproxied: false,\n\tcleanup_out_msgs: 1000,\n\tcorsOptions: { origin: true },\n};\n\nexport default defaultConfig;\n","import type express from \"express\";\nimport type { Server as HttpServer } from \"node:http\";\nimport type { Server as HttpsServer } from \"node:https\";\nimport path from \"node:path\";\nimport type { IRealm } from \"./models/realm.ts\";\nimport { Realm } from \"./models/realm.ts\";\nimport { CheckBrokenConnections } from \"./services/checkBrokenConnections/index.ts\";\nimport type { IMessagesExpire } from \"./services/messagesExpire/index.ts\";\nimport { MessagesExpire } from \"./services/messagesExpire/index.ts\";\nimport type { IWebSocketServer } from \"./services/webSocketServer/index.ts\";\nimport { WebSocketServer } from \"./services/webSocketServer/index.ts\";\nimport { MessageHandler } from \"./messageHandler/index.ts\";\nimport { Api } from \"./api/index.ts\";\nimport type { IClient } from \"./models/client.ts\";\nimport type { IMessage } from \"./models/message.ts\";\nimport type { IConfig } from \"./config/index.ts\";\n\nexport interface PeerServerEvents {\n\ton(event: \"connection\", listener: (client: IClient) => void): this;\n\ton(\n\t\tevent: \"message\",\n\t\tlistener: (client: IClient, message: IMessage) => void,\n\t): this;\n\t// eslint-disable-next-line @typescript-eslint/unified-signatures\n\ton(event: \"disconnect\", listener: (client: IClient) => void): this;\n\ton(event: \"error\", listener: (client: Error) => void): this;\n}\n\nexport const createInstance = ({\n\tapp,\n\tserver,\n\toptions,\n}: {\n\tapp: express.Application;\n\tserver: HttpServer | HttpsServer;\n\toptions: IConfig;\n}): void => {\n\tconst config = options;\n\tconst realm: IRealm = new Realm();\n\tconst messageHandler = new MessageHandler(realm);\n\n\tconst api = Api({ config, realm, corsOptions: options.corsOptions });\n\tconst messagesExpire: IMessagesExpire = new MessagesExpire({\n\t\trealm,\n\t\tconfig,\n\t\tmessageHandler,\n\t});\n\tconst checkBrokenConnections = new CheckBrokenConnections({\n\t\trealm,\n\t\tconfig,\n\t\tonClose: (client) => {\n\t\t\tapp.emit(\"disconnect\", client);\n\t\t},\n\t});\n\n\tapp.use(options.path, api);\n\n\t//use mountpath for WS server\n\tconst customConfig = {\n\t\t...config,\n\t\tpath: path.posix.join(app.path(), options.path, \"/\"),\n\t};\n\n\tconst wss: IWebSocketServer = new WebSocketServer({\n\t\tserver,\n\t\trealm,\n\t\tconfig: customConfig,\n\t});\n\n\twss.on(\"connection\", (client: IClient) => {\n\t\tconst messageQueue = realm.getMessageQueueById(client.getId());\n\n\t\tif (messageQueue) {\n\t\t\tlet message: IMessage | undefined;\n\n\t\t\twhile ((message = messageQueue.readMessage())) {\n\t\t\t\tmessageHandler.handle(client, message);\n\t\t\t}\n\t\t\trealm.clearMessageQueue(client.getId());\n\t\t}\n\n\t\tapp.emit(\"connection\", client);\n\t});\n\n\twss.on(\"message\", (client: IClient, message: IMessage) => {\n\t\tapp.emit(\"message\", client, message);\n\t\tmessageHandler.handle(client, message);\n\t});\n\n\twss.on(\"close\", (client: IClient) => {\n\t\tapp.emit(\"disconnect\", client);\n\t});\n\n\twss.on(\"error\", (error: Error) => {\n\t\tapp.emit(\"error\", error);\n\t});\n\n\tmessagesExpire.startMessagesExpiration();\n\tcheckBrokenConnections.start();\n};\n","import type { IMessageQueue } from \"./messageQueue.ts\";\nimport { MessageQueue } from \"./messageQueue.ts\";\nimport { randomUUID } from \"node:crypto\";\nimport type { IClient } from \"./client.ts\";\nimport type { IMessage } from \"./message.ts\";\n\nexport interface IRealm {\n\tgetClientsIds(): string[];\n\n\tgetClientById(clientId: string): IClient | undefined;\n\n\tgetClientsIdsWithQueue(): string[];\n\n\tsetClient(client: IClient, id: string): void;\n\n\tremoveClientById(id: string): boolean;\n\n\tgetMessageQueueById(id: string): IMessageQueue | undefined;\n\n\taddMessageToQueue(id: string, message: IMessage): void;\n\n\tclearMessageQueue(id: string): void;\n\n\tgenerateClientId(generateClientId?: () => string): string;\n}\n\nexport class Realm implements IRealm {\n\tprivate readonly clients = new Map<string, IClient>();\n\tprivate readonly messageQueues = new Map<string, IMessageQueue>();\n\n\tpublic getClientsIds(): string[] {\n\t\treturn [...this.clients.keys()];\n\t}\n\n\tpublic getClientById(clientId: string): IClient | undefined {\n\t\treturn this.clients.get(clientId);\n\t}\n\n\tpublic getClientsIdsWithQueue(): string[] {\n\t\treturn [...this.messageQueues.keys()];\n\t}\n\n\tpublic setClient(client: IClient, id: string): void {\n\t\tthis.clients.set(id, client);\n\t}\n\n\tpublic removeClientById(id: string): boolean {\n\t\tconst client = this.getClientById(id);\n\n\t\tif (!client) return false;\n\n\t\tthis.clients.delete(id);\n\n\t\treturn true;\n\t}\n\n\tpublic getMessageQueueById(id: string): IMessageQueue | undefined {\n\t\treturn this.messageQueues.get(id);\n\t}\n\n\tpublic addMessageToQueue(id: string, message: IMessage): void {\n\t\tif (!this.getMessageQueueById(id)) {\n\t\t\tthis.messageQueues.set(id, new MessageQueue());\n\t\t}\n\n\t\tthis.getMessageQueueById(id)?.addMessage(message);\n\t}\n\n\tpublic clearMessageQueue(id: string): void {\n\t\tthis.messageQueues.delete(id);\n\t}\n\n\tpublic generateClientId(generateClientId?: () => string): string {\n\t\tconst generateId = generateClientId ? generateClientId : randomUUID;\n\n\t\tlet clientId = generateId();\n\n\t\twhile (this.getClientById(clientId)) {\n\t\t\tclientId = generateId();\n\t\t}\n\n\t\treturn clientId;\n\t}\n}\n","import type { IMessage } from \"./message.ts\";\n\nexport interface IMessageQueue {\n\tgetLastReadAt(): number;\n\n\taddMessage(message: IMessage): void;\n\n\treadMessage(): IMessage | undefined;\n\n\tgetMessages(): IMessage[];\n}\n\nexport class MessageQueue implements IMessageQueue {\n\tprivate lastReadAt: number = new Date().getTime();\n\tprivate readonly messages: IMessage[] = [];\n\n\tpublic getLastReadAt(): number {\n\t\treturn this.lastReadAt;\n\t}\n\n\tpublic addMessage(message: IMessage): void {\n\t\tthis.messages.push(message);\n\t}\n\n\tpublic readMessage(): IMessage | undefined {\n\t\tif (this.messages.length > 0) {\n\t\t\tthis.lastReadAt = new Date().getTime();\n\t\t\treturn this.messages.shift();\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tpublic getMessages(): IMessage[] {\n\t\treturn this.messages;\n\t}\n}\n","import type { IConfig } from \"../../config/index.ts\";\nimport type { IClient } from \"../../models/client.ts\";\nimport type { IRealm } from \"../../models/realm.ts\";\n\nconst DEFAULT_CHECK_INTERVAL = 300;\n\ntype CustomConfig = Pick<IConfig, \"alive_timeout\">;\n\nexport class CheckBrokenConnections {\n\tpublic readonly checkInterval: number;\n\tprivate timeoutId: NodeJS.Timeout | null = null;\n\tprivate readonly realm: IRealm;\n\tprivate readonly config: CustomConfig;\n\tprivate readonly onClose?: (client: IClient) => void;\n\n\tconstructor({\n\t\trealm,\n\t\tconfig,\n\t\tcheckInterval = DEFAULT_CHECK_INTERVAL,\n\t\tonClose,\n\t}: {\n\t\trealm: IRealm;\n\t\tconfig: CustomConfig;\n\t\tcheckInterval?: number;\n\t\tonClose?: (client: IClient) => void;\n\t}) {\n\t\tthis.realm = realm;\n\t\tthis.config = config;\n\t\tthis.onClose = onClose;\n\t\tthis.checkInterval = checkInterval;\n\t}\n\n\tpublic start(): void {\n\t\tif (this.timeoutId) {\n\t\t\tclearTimeout(this.timeoutId);\n\t\t}\n\n\t\tthis.timeoutId = setTimeout(() => {\n\t\t\tthis.checkConnections();\n\n\t\t\tthis.timeoutId = null;\n\n\t\t\tthis.start();\n\t\t}, this.checkInterval);\n\t}\n\n\tpublic stop(): void {\n\t\tif (this.timeoutId) {\n\t\t\tclearTimeout(this.timeoutId);\n\t\t\tthis.timeoutId = null;\n\t\t}\n\t}\n\n\tprivate checkConnections(): void {\n\t\tconst clientsIds = this.realm.getClientsIds();\n\n\t\tconst now = new Date().getTime();\n\t\tconst { alive_timeout: aliveTimeout } = this.config;\n\n\t\tfor (const clientId of clientsIds) {\n\t\t\tconst client = this.realm.getClientById(clientId);\n\n\t\t\tif (!client) continue;\n\n\t\t\tconst timeSinceLastPing = now - client.getLastPing();\n\n\t\t\tif (timeSinceLastPing < aliveTimeout) continue;\n\n\t\t\ttry {\n\t\t\t\tclient.getSocket()?.close();\n\t\t\t} finally {\n\t\t\t\tthis.realm.clearMessageQueue(clientId);\n\t\t\t\tthis.realm.removeClientById(clientId);\n\n\t\t\t\tclient.setSocket(null);\n\n\t\t\t\tthis.onClose?.(client);\n\t\t\t}\n\t\t}\n\t}\n}\n","import { MessageType } from \"../../enums.ts\";\nimport type { IConfig } from \"../../config/index.ts\";\nimport type { IMessageHandler } from \"../../messageHandler/index.ts\";\nimport type { IRealm } from \"../../models/realm.ts\";\n\nexport interface IMessagesExpire {\n\tstartMessagesExpiration(): void;\n\tstopMessagesExpiration(): void;\n}\n\ntype CustomConfig = Pick<IConfig, \"cleanup_out_msgs\" | \"expire_timeout\">;\n\nexport class MessagesExpire implements IMessagesExpire {\n\tprivate readonly realm: IRealm;\n\tprivate readonly config: CustomConfig;\n\tprivate readonly messageHandler: IMessageHandler;\n\n\tprivate timeoutId: NodeJS.Timeout | null = null;\n\n\tconstructor({\n\t\trealm,\n\t\tconfig,\n\t\tmessageHandler,\n\t}: {\n\t\trealm: IRealm;\n\t\tconfig: CustomConfig;\n\t\tmessageHandler: IMessageHandler;\n\t}) {\n\t\tthis.realm = realm;\n\t\tthis.config = config;\n\t\tthis.messageHandler = messageHandler;\n\t}\n\n\tpublic startMessagesExpiration(): void {\n\t\tif (this.timeoutId) {\n\t\t\tclearTimeout(this.timeoutId);\n\t\t}\n\n\t\t// Clean up outstanding messages\n\t\tthis.timeoutId = setTimeout(() => {\n\t\t\tthis.pruneOutstanding();\n\n\t\t\tthis.timeoutId = null;\n\n\t\t\tthis.startMessagesExpiration();\n\t\t}, this.config.cleanup_out_msgs);\n\t}\n\n\tpublic stopMessagesExpiration(): void {\n\t\tif (this.timeoutId) {\n\t\t\tclearTimeout(this.timeoutId);\n\t\t\tthis.timeoutId = null;\n\t\t}\n\t}\n\n\tprivate pruneOutstanding(): void {\n\t\tconst destinationClientsIds = this.realm.getClientsIdsWithQueue();\n\n\t\tconst now = new Date().getTime();\n\t\tconst maxDiff = this.config.expire_timeout;\n\n\t\tconst seen: Record<string, boolean> = {};\n\n\t\tfor (const destinationClientId of destinationClientsIds) {\n\t\t\tconst messageQueue = this.realm.getMessageQueueById(destinationClientId);\n\n\t\t\tif (!messageQueue) continue;\n\n\t\t\tconst lastReadDiff = now - messageQueue.getLastReadAt();\n\n\t\t\tif (lastReadDiff < maxDiff) continue;\n\n\t\t\tconst messages = messageQueue.getMessages();\n\n\t\t\tfor (const message of messages) {\n\t\t\t\tconst seenKey = `${message.src}_${message.dst}`;\n\n\t\t\t\tif (!seen[seenKey]) {\n\t\t\t\t\tthis.messageHandler.handle(undefined, {\n\t\t\t\t\t\ttype: MessageType.EXPIRE,\n\t\t\t\t\t\tsrc: message.dst,\n\t\t\t\t\t\tdst: message.src,\n\t\t\t\t\t});\n\n\t\t\t\t\tseen[seenKey] = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.realm.clearMessageQueue(destinationClientId);\n\t\t}\n\t}\n}\n","export enum Errors {\n\tINVALID_KEY = \"Invalid key provided\",\n\tINVALID_TOKEN = \"Invalid token provided\",\n\tINVALID_WS_PARAMETERS = \"No id, token, or key supplied to websocket server\",\n\tCONNECTION_LIMIT_EXCEED = \"Server has reached its concurrent user limit\",\n}\n\nexport enum MessageType {\n\tOPEN = \"OPEN\",\n\tLEAVE = \"LEAVE\",\n\tCANDIDATE = \"CANDIDATE\",\n\tOFFER = \"OFFER\",\n\tANSWER = \"ANSWER\",\n\tEXPIRE = \"EXPIRE\",\n\tHEARTBEAT = \"HEARTBEAT\",\n\tID_TAKEN = \"ID-TAKEN\",\n\tERROR = \"ERROR\",\n}\n","import { EventEmitter } from \"node:events\";\nimport type { IncomingMessage } from \"node:http\";\nimport type WebSocket from \"ws\";\nimport { Errors, MessageType } from \"../../enums.ts\";\nimport type { IClient } from \"../../models/client.ts\";\nimport { Client } from \"../../models/client.ts\";\nimport type { IConfig } from \"../../config/index.ts\";\nimport type { IRealm } from \"../../models/realm.ts\";\nimport { WebSocketServer as Server } from \"ws\";\nimport type { Server as HttpServer } from \"node:http\";\nimport type { Server as HttpsServer } from \"node:https\";\nimport { IMessage } from \"../../models/message.js\";\n\nexport interface IWebSocketServer extends EventEmitter {\n\treadonly path: string;\n}\n\ntype CustomConfig = Pick<\n\tIConfig,\n\t\"path\" | \"key\" | \"concurrent_limit\" | \"createWebSocketServer\"\n>;\n\nconst WS_PATH = \"peerjs\";\n\nexport class WebSocketServer extends EventEmitter implements IWebSocketServer {\n\tpublic readonly path: string;\n\tprivate readonly realm: IRealm;\n\tprivate readonly config: CustomConfig;\n\tpublic readonly socketServer: Server;\n\n\tconstructor({\n\t\tserver,\n\t\trealm,\n\t\tconfig,\n\t}: {\n\t\tserver: HttpServer | HttpsServer;\n\t\trealm: IRealm;\n\t\tconfig: CustomConfig;\n\t}) {\n\t\tsuper();\n\n\t\tthis.setMaxListeners(0);\n\n\t\tthis.realm = realm;\n\t\tthis.config = config;\n\n\t\tconst path = this.config.path;\n\t\tthis.path = `${path}${path.endsWith(\"/\") ? \"\" : \"/\"}${WS_PATH}`;\n\n\t\tconst options: WebSocket.ServerOptions = {\n\t\t\tpath: this.path,\n\t\t\tserver,\n\t\t};\n\n\t\tthis.socketServer = config.createWebSocketServer\n\t\t\t? config.createWebSocketServer(options)\n\t\t\t: new Server(options);\n\n\t\tthis.socketServer.on(\"connection\", (socket, req) => {\n\t\t\tthis._onSocketConnection(socket, req);\n\t\t});\n\t\tthis.socketServer.on(\"error\", (error: Error) => {\n\t\t\tthis._onSocketError(error);\n\t\t});\n\t}\n\n\tprivate _onSocketConnection(socket: WebSocket, req: IncomingMessage): void {\n\t\t// An unhandled socket error might crash the server. Handle it first.\n\t\tsocket.on(\"error\", (error) => {\n\t\t\tthis._onSocketError(error);\n\t\t});\n\n\t\t// We are only interested in the query, the base url is therefore not relevant\n\t\tconst { searchParams } = new URL(req.url ?? \"\", \"https://peerjs\");\n\t\tconst { id, token, key } = Object.fromEntries(searchParams.entries());\n\n\t\tif (!id || !token || !key) {\n\t\t\tthis._sendErrorAndClose(socket, Errors.INVALID_WS_PARAMETERS);\n\t\t\treturn;\n\t\t}\n\n\t\tif (key !== this.config.key) {\n\t\t\tthis._sendErrorAndClose(socket, Errors.INVALID_KEY);\n\t\t\treturn;\n\t\t}\n\n\t\tconst client = this.realm.getClientById(id);\n\n\t\tif (client) {\n\t\t\tif (token !== client.getToken()) {\n\t\t\t\t// ID-taken, invalid token\n\t\t\t\tsocket.send(\n\t\t\t\t\tJSON.stringify({\n\t\t\t\t\t\ttype: MessageType.ID_TAKEN,\n\t\t\t\t\t\tpayload: { msg: \"ID is taken\" },\n\t\t\t\t\t}),\n\t\t\t\t);\n\n\t\t\t\tsocket.close();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._configureWS(socket, client);\n\t\t\treturn;\n\t\t}\n\n\t\tthis._registerClient({ socket, id, token });\n\t}\n\n\tprivate _onSocketError(error: Error): void {\n\t\t// handle error\n\t\tthis.emit(\"error\", error);\n\t}\n\n\tprivate _registerClient({\n\t\tsocket,\n\t\tid,\n\t\ttoken,\n\t}: {\n\t\tsocket: WebSocket;\n\t\tid: string;\n\t\ttoken: string;\n\t}): void {\n\t\t// Check concurrent limit\n\t\tconst clientsCount = this.realm.getClientsIds().length;\n\n\t\tif (clientsCount >= this.config.concurrent_limit) {\n\t\t\tthis._sendErrorAndClose(socket, Errors.CONNECTION_LIMIT_EXCEED);\n\t\t\treturn;\n\t\t}\n\n\t\tconst newClient: IClient = new Client({ id, token });\n\t\tthis.realm.setClient(newClient, id);\n\t\tsocket.send(JSON.stringify({ type: MessageType.OPEN }));\n\n\t\tthis._configureWS(socket, newClient);\n\t}\n\n\tprivate _configureWS(socket: WebSocket, client: IClient): void {\n\t\tclient.setSocket(socket);\n\n\t\t// Cleanup after a socket closes.\n\t\tsocket.on(\"close\", () => {\n\t\t\tif (client.getSocket() === socket) {\n\t\t\t\tthis.realm.removeClientById(client.getId());\n\t\t\t\tthis.emit(\"close\", client);\n\t\t\t}\n\t\t});\n\n\t\t// Handle messages from peers.\n\t\tsocket.on(\"message\", (data) => {\n\t\t\ttry {\n\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-base-to-string\n\t\t\t\tconst message = JSON.parse(data.toString()) as Writable<IMessage>;\n\n\t\t\t\tmessage.src = client.getId();\n\n\t\t\t\tthis.emit(\"message\", client, message);\n\t\t\t} catch (e) {\n\t\t\t\tthis.emit(\"error\", e);\n\t\t\t}\n\t\t});\n\n\t\tthis.emit(\"connection\", client);\n\t}\n\n\tprivate _sendErrorAndClose(socket: WebSocket, msg: Errors): void {\n\t\tsocket.send(\n\t\t\tJSON.stringify({\n\t\t\t\ttype: MessageType.ERROR,\n\t\t\t\tpayload: { msg },\n\t\t\t}),\n\t\t);\n\n\t\tsocket.close();\n\t}\n}\n\ntype Writable<T> = {\n\t-readonly [K in keyof T]: T[K];\n};\n","import type WebSocket from \"ws\";\n\nexport interface IClient {\n\tgetId(): string;\n\n\tgetToken(): string;\n\n\tgetSocket(): WebSocket | null;\n\n\tsetSocket(socket: WebSocket | null): void;\n\n\tgetLastPing(): number;\n\n\tsetLastPing(lastPing: number): void;\n\n\tsend<T>(data: T): void;\n}\n\nexport class Client implements IClient {\n\tprivate readonly id: string;\n\tprivate readonly token: string;\n\tprivate socket: WebSocket | null = null;\n\tprivate lastPing: number = new Date().getTime();\n\n\tconstructor({ id, token }: { id: string; token: string }) {\n\t\tthis.id = id;\n\t\tthis.token = token;\n\t}\n\n\tpublic getId(): string {\n\t\treturn this.id;\n\t}\n\n\tpublic getToken(): string {\n\t\treturn this.token;\n\t}\n\n\tpublic getSocket(): WebSocket | null {\n\t\treturn this.socket;\n\t}\n\n\tpublic setSocket(socket: WebSocket | null): void {\n\t\tthis.socket = socket;\n\t}\n\n\tpublic getLastPing(): number {\n\t\treturn this.lastPing;\n\t}\n\n\tpublic setLastPing(lastPing: number): void {\n\t\tthis.lastPing = lastPing;\n\t}\n\n\tpublic send<T>(data: T): void {\n\t\tthis.socket?.send(JSON.stringify(data));\n\t}\n}\n","import { MessageType } from \"../enums.ts\";\nimport { HeartbeatHandler, TransmissionHandler } from \"./handlers/index.ts\";\nimport type { IHandlersRegistry } from \"./handlersRegistry.ts\";\nimport { HandlersRegistry } from \"./handlersRegistry.ts\";\nimport type { IClient } from \"../models/client.ts\";\nimport type { IMessage } from \"../models/message.ts\";\nimport type { IRealm } from \"../models/realm.ts\";\nimport type { Handler } from \"./handler.ts\";\n\nexport interface IMessageHandler {\n\thandle(client: IClient | undefined, message: IMessage): boolean;\n}\n\nexport class MessageHandler implements IMessageHandler {\n\tconstructor(\n\t\trealm: IRealm,\n\t\tprivate readonly handlersRegistry: IHandlersRegistry = new HandlersRegistry(),\n\t) {\n\t\tconst transmissionHandler: Handler = TransmissionHandler({ realm });\n\t\tconst heartbeatHandler: Handler = HeartbeatHandler;\n\n\t\tconst handleTransmission: Handler = (\n\t\t\tclient: IClient | undefined,\n\t\t\t{ type, src, dst, payload }: IMessage,\n\t\t): boolean => {\n\t\t\treturn transmissionHandler(client, {\n\t\t\t\ttype,\n\t\t\t\tsrc,\n\t\t\t\tdst,\n\t\t\t\tpayload,\n\t\t\t});\n\t\t};\n\n\t\tconst handleHeartbeat = (client: IClient | undefined, message: IMessage) =>\n\t\t\theartbeatHandler(client, message);\n\n\t\tthis.handlersRegistry.registerHandler(\n\t\t\tMessageType.HEARTBEAT,\n\t\t\thandleHeartbeat,\n\t\t);\n\t\tthis.handlersRegistry.registerHandler(\n\t\t\tMessageType.OFFER,\n\t\t\thandleTransmission,\n\t\t);\n\t\tthis.handlersRegistry.registerHandler(\n\t\t\tMessageType.ANSWER,\n\t\t\thandleTransmission,\n\t\t);\n\t\tthis.handlersRegistry.registerHandler(\n\t\t\tMessageType.CANDIDATE,\n\t\t\thandleTransmission,\n\t\t);\n\t\tthis.handlersRegistry.registerHandler(\n\t\t\tMessageType.LEAVE,\n\t\t\thandleTransmission,\n\t\t);\n\t\tthis.handlersRegistry.registerHandler(\n\t\t\tMessageType.EXPIRE,\n\t\t\thandleTransmission,\n\t\t);\n\t}\n\n\tpublic handle(client: IClient | undefined, message: IMessage): boolean {\n\t\treturn this.handlersRegistry.handle(client, message);\n\t}\n}\n","export { HeartbeatHandler } from \"./heartbeat/index.ts\";\nexport { TransmissionHandler } from \"./transmission/index.ts\";\n","import type { IClient } from \"../../../models/client.ts\";\n\nexport const HeartbeatHandler = (client: IClient | undefined): boolean => {\n\tif (client) {\n\t\tconst nowTime = new Date().getTime();\n\t\tclient.setLastPing(nowTime);\n\t}\n\n\treturn true;\n};\n","import { MessageType } from \"../../../enums.ts\";\nimport type { IClient } from \"../../../models/client.ts\";\nimport type { IMessage } from \"../../../models/message.ts\";\nimport type { IRealm } from \"../../../models/realm.ts\";\n\nexport const TransmissionHandler = ({\n\trealm,\n}: {\n\trealm: IRealm;\n}): ((client: IClient | undefined, message: IMessage) => boolean) => {\n\tconst handle = (client: IClient | undefined, message: IMessage) => {\n\t\tconst type = message.type;\n\t\tconst srcId = message.src;\n\t\tconst dstId = message.dst;\n\n\t\tconst destinationClient = realm.getClientById(dstId);\n\n\t\t// User is connected!\n\t\tif (destinationClient) {\n\t\t\tconst socket = destinationClient.getSocket();\n\t\t\ttry {\n\t\t\t\tif (socket) {\n\t\t\t\t\tconst data = JSON.stringify(message);\n\n\t\t\t\t\tsocket.send(data);\n\t\t\t\t} else {\n\t\t\t\t\t// Neither socket no res available. Peer dead?\n\t\t\t\t\tthrow new Error(\"Peer dead\");\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t// This happens when a peer disconnects without closing connections and\n\t\t\t\t// the associated WebSocket has not closed.\n\t\t\t\t// Tell other side to stop trying.\n\t\t\t\tif (socket) {\n\t\t\t\t\tsocket.close();\n\t\t\t\t} else {\n\t\t\t\t\trealm.removeClientById(destinationClient.getId());\n\t\t\t\t}\n\n\t\t\t\thandle(client, {\n\t\t\t\t\ttype: MessageType.LEAVE,\n\t\t\t\t\tsrc: dstId,\n\t\t\t\t\tdst: srcId,\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\t// Wait for this client to connect/reconnect (XHR) for important\n\t\t\t// messages.\n\t\t\tconst ignoredTypes = [MessageType.LEAVE, MessageType.EXPIRE];\n\n\t\t\tif (!ignoredTypes.includes(type) && dstId) {\n\t\t\t\trealm.addMessageToQueue(dstId, message);\n\t\t\t} else if (type === MessageType.LEAVE && !dstId) {\n\t\t\t\trealm.removeClientById(srcId);\n\t\t\t} else {\n\t\t\t\t// Unavailable destination specified with message LEAVE or EXPIRE\n\t\t\t\t// Ignore\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t};\n\n\treturn handle;\n};\n","import type { MessageType } from \"../enums.ts\";\nimport type { IClient } from \"../models/client.ts\";\nimport type { IMessage } from \"../models/message.ts\";\nimport type { Handler } from \"./handler.ts\";\n\nexport interface IHandlersRegistry {\n\tregisterHandler(messageType: MessageType, handler: Handler): void;\n\thandle(client: IClient | undefined, message: IMessage): boolean;\n}\n\nexport class HandlersRegistry implements IHandlersRegistry {\n\tprivate readonly handlers = new Map<MessageType, Handler>();\n\n\tpublic registerHandler(messageType: MessageType, handler: Handler): void {\n\t\tif (this.handlers.has(messageType)) return;\n\n\t\tthis.handlers.set(messageType, handler);\n\t}\n\n\tpublic handle(client: IClient | undefined, message: IMessage): boolean {\n\t\tconst { type } = message;\n\n\t\tconst handler = this.handlers.get(type);\n\n\t\tif (!handler) return false;\n\n\t\treturn handler(client, message);\n\t}\n}\n","import cors, { CorsOptions } from \"cors\";\nimport express from \"express\";\nimport publicContent from \"../../app.json\";\nimport PublicApi from \"./v1/public/index.ts\";\nimport type { IConfig } from \"../config/index.ts\";\nimport type { IRealm } from \"../models/realm.ts\";\n\nexport const Api = ({\n\tconfig,\n\trealm,\n\tcorsOptions,\n}: {\n\tconfig: IConfig;\n\trealm: IRealm;\n\tcorsOptions: CorsOptions;\n}): express.Router => {\n\tconst app = express.Router();\n\n\tapp.use(cors(corsOptions));\n\n\tapp.get(\"/\", (_, res) => {\n\t\tres.send(publicContent);\n\t});\n\n\tapp.use(\"/:key\", PublicApi({ config, realm }));\n\n\treturn app;\n};\n","{\n\t\"name\": \"PeerJS Server\",\n\t\"description\": \"A server side element to broker connections between PeerJS clients.\",\n\t\"website\": \"https://peerjs.com/\"\n}\n","import express from \"express\";\nimport type { IConfig } from \"../../../config/index.ts\";\nimport type { IRealm } from \"../../../models/realm.ts\";\n\nexport default ({\n\tconfig,\n\trealm,\n}: {\n\tconfig: IConfig;\n\trealm: IRealm;\n}): express.Router => {\n\tconst app = express.Router();\n\n\t// Retrieve guaranteed random ID.\n\tapp.get(\"/id\", (_, res: express.Response) => {\n\t\tres.contentType(\"html\");\n\t\tres.send(realm.generateClientId(config.generateClientId));\n\t});\n\n\t// Get a list of all peers for a key, enabled by the `allowDiscovery` flag.\n\tapp.get(\"/peers\", (_, res: express.Response) => {\n\t\tif (config.allow_discovery) {\n\t\t\tconst clientsIds = realm.getClientsIds();\n\n\t\t\treturn res.send(clientsIds);\n\t\t}\n\n\t\treturn res.sendStatus(401);\n\t});\n\n\treturn app;\n};\n"],"names":["$7BbP7$nodepath","$7BbP7$nodefs","$7BbP7$yargs","hideBin","$7BbP7$hideBin","$7BbP7$express","$7BbP7$nodehttp","$7BbP7$nodehttps","randomUUID","$7BbP7$randomUUID","EventEmitter","$7BbP7$EventEmitter","WebSocketServer","$7BbP7$WebSocketServer","$7BbP7$cors","Errors","MessageType","$d461d7260b6fc353$export$b8e9cd941e8016ac","$d461d7260b6fc353$export$80edbf15fa61a4db","$aeb1147dec1b7a02$export$2e2bcd8739ae039","host","port","expire_timeout","alive_timeout","key","path","concurrent_limit","allow_discovery","proxied","cleanup_out_msgs","corsOptions","origin","$2c42eaf0ccc66758$export$eb4c623330d4cbcc","getLastReadAt","lastReadAt","addMessage","message","messages","push","readMessage","length","Date","getTime","shift","getMessages","constructor","$0a339ca52e0451c9$export$3ee29d34e33d9116","getClientsIds","clients","keys","getClientById","clientId","get","getClientsIdsWithQueue","messageQueues","setClient","client","id","set","removeClientById","delete","getMessageQueueById","addMessageToQueue","clearMessageQueue","generateClientId","generateId","Map","$6840aafc61c9abd6$export$6fa53df6b5b88df7","realm","config","checkInterval","onClose","timeoutId","start","clearTimeout","setTimeout","checkConnections","stop","clientsIds","now","aliveTimeout","timeSinceLastPing","getLastPing","getSocket","close","setSocket","$c97baf9b78981954$export$a13b411d0e88b1af","messageHandler","startMessagesExpiration","pruneOutstanding","stopMessagesExpiration","destinationClientsIds","maxDiff","seen","destinationClientId","messageQueue","lastReadDiff","seenKey","src","dst","handle","undefined","type","EXPIRE","$d09fcb6ab78a3f48$export$1f2bb630327ac4b6","token","socket","lastPing","getId","getToken","setLastPing","send","data","JSON","stringify","$4ae24f8b3b7cf7b0$export$f47674b57e51ee3b","server","setMaxListeners","endsWith","options","socketServer","createWebSocketServer","on","req","_onSocketConnection","error","_onSocketError","searchParams","URL","url","Object","fromEntries","entries","_sendErrorAndClose","INVALID_WS_PARAMETERS","INVALID_KEY","ID_TAKEN","payload","msg","_configureWS","_registerClient","emit","clientsCount","CONNECTION_LIMIT_EXCEED","newClient","OPEN","parse","toString","e","ERROR","$c523c19e3fc944a1$export$65302b915833a46d","nowTime","$879e80f95ec634eb$export$809c011ea942310","srcId","dstId","destinationClient","Error","LEAVE","ignoredTypes","includes","$df0509eaca4ae82c$export$cfe4a96645b0bbcf","registerHandler","messageType","handler","handlers","has","$3089a9bad51bbb04$export$3deceafe0aaeaa95","handlersRegistry","transmissionHandler","handleTransmission","HEARTBEAT","heartbeatHandler","OFFER","ANSWER","CANDIDATE","$264fdbd7932d14df$exports","$6910ff2a5db5006f$export$2e2bcd8739ae039","app","Router","_","res","contentType","sendStatus","$69f9994c6ebd6802$export$bf71da7aebe9ddc1","use","a","__esModule","default","$e7d4fd16baa81890$export$99152e8d49ca4e7d","api","messagesExpire","checkBrokenConnections","wss","posix","join","$3809f3d53201df9f$var$y","process","argv","$3809f3d53201df9f$var$portEnvIsSet","env","$3809f3d53201df9f$var$opts","usage","wrap","Math","min","terminalWidth","demandOption","alias","describe","sslkey","sslcert","cors","array","boolean","parseSync","parseInt","console","readFileSync","resolve","cert","exit","$3809f3d53201df9f$var$userPath","$3809f3d53201df9f$var$server","callback","newOptions","ssl","restOptions","createServer","peerjs","$0fe9c43b5c368182$export$8c57434a18c696c9","listen","address","log","shutdownApp"],"version":3,"file":"peerjs.js.map","sourceRoot":"../../"}