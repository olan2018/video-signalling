#!/usr/bin/env node
import e from"node:path";import t from"node:fs";import s from"yargs";import{hideBin as r}from"yargs/helpers";import i from"express";import n from"node:http";import o from"node:https";import{randomUUID as a}from"node:crypto";import{EventEmitter as l}from"node:events";import{WebSocketServer as c}from"ws";import d from"cors";var h,g,u,m,p={host:"::",port:9e3,expire_timeout:5e3,alive_timeout:9e4,key:"peerjs",path:"/",concurrent_limit:5e3,allow_discovery:!1,proxied:!1,cleanup_out_msgs:1e3,corsOptions:{origin:!0}};class y{getLastReadAt(){return this.lastReadAt}addMessage(e){this.messages.push(e)}readMessage(){if(this.messages.length>0)return this.lastReadAt=new Date().getTime(),this.messages.shift()}getMessages(){return this.messages}constructor(){this.lastReadAt=new Date().getTime(),this.messages=[]}}class I{getClientsIds(){return[...this.clients.keys()]}getClientById(e){return this.clients.get(e)}getClientsIdsWithQueue(){return[...this.messageQueues.keys()]}setClient(e,t){this.clients.set(t,e)}removeClientById(e){return!!this.getClientById(e)&&(this.clients.delete(e),!0)}getMessageQueueById(e){return this.messageQueues.get(e)}addMessageToQueue(e,t){this.getMessageQueueById(e)||this.messageQueues.set(e,new y),this.getMessageQueueById(e)?.addMessage(t)}clearMessageQueue(e){this.messageQueues.delete(e)}generateClientId(e){let t=e||a,s=t();for(;this.getClientById(s);)s=t();return s}constructor(){this.clients=new Map,this.messageQueues=new Map}}class E{constructor({realm:e,config:t,checkInterval:s=300,onClose:r}){this.timeoutId=null,this.realm=e,this.config=t,this.onClose=r,this.checkInterval=s}start(){this.timeoutId&&clearTimeout(this.timeoutId),this.timeoutId=setTimeout(()=>{this.checkConnections(),this.timeoutId=null,this.start()},this.checkInterval)}stop(){this.timeoutId&&(clearTimeout(this.timeoutId),this.timeoutId=null)}checkConnections(){let e=this.realm.getClientsIds(),t=new Date().getTime(),{alive_timeout:s}=this.config;for(let r of e){let e=this.realm.getClientById(r);if(e&&!(t-e.getLastPing()<s))try{e.getSocket()?.close()}finally{this.realm.clearMessageQueue(r),this.realm.removeClientById(r),e.setSocket(null),this.onClose?.(e)}}}}(h=u||(u={})).INVALID_KEY="Invalid key provided",h.INVALID_TOKEN="Invalid token provided",h.INVALID_WS_PARAMETERS="No id, token, or key supplied to websocket server",h.CONNECTION_LIMIT_EXCEED="Server has reached its concurrent user limit",(g=m||(m={})).OPEN="OPEN",g.LEAVE="LEAVE",g.CANDIDATE="CANDIDATE",g.OFFER="OFFER",g.ANSWER="ANSWER",g.EXPIRE="EXPIRE",g.HEARTBEAT="HEARTBEAT",g.ID_TAKEN="ID-TAKEN",g.ERROR="ERROR";class f{constructor({realm:e,config:t,messageHandler:s}){this.timeoutId=null,this.realm=e,this.config=t,this.messageHandler=s}startMessagesExpiration(){this.timeoutId&&clearTimeout(this.timeoutId),this.timeoutId=setTimeout(()=>{this.pruneOutstanding(),this.timeoutId=null,this.startMessagesExpiration()},this.config.cleanup_out_msgs)}stopMessagesExpiration(){this.timeoutId&&(clearTimeout(this.timeoutId),this.timeoutId=null)}pruneOutstanding(){let e=this.realm.getClientsIdsWithQueue(),t=new Date().getTime(),s=this.config.expire_timeout,r={};for(let i of e){let e=this.realm.getMessageQueueById(i);if(!(!e||t-e.getLastReadAt()<s)){for(let t of e.getMessages()){let e=`${t.src}_${t.dst}`;r[e]||(this.messageHandler.handle(void 0,{type:m.EXPIRE,src:t.dst,dst:t.src}),r[e]=!0)}this.realm.clearMessageQueue(i)}}}}class S{constructor({id:e,token:t}){this.socket=null,this.lastPing=new Date().getTime(),this.id=e,this.token=t}getId(){return this.id}getToken(){return this.token}getSocket(){return this.socket}setSocket(e){this.socket=e}getLastPing(){return this.lastPing}setLastPing(e){this.lastPing=e}send(e){this.socket?.send(JSON.stringify(e))}}class k extends l{constructor({server:e,realm:t,config:s}){super(),this.setMaxListeners(0),this.realm=t,this.config=s;let r=this.config.path;this.path=`${r}${r.endsWith("/")?"":"/"}peerjs`;let i={path:this.path,server:e};this.socketServer=s.createWebSocketServer?s.createWebSocketServer(i):new c(i),this.socketServer.on("connection",(e,t)=>{this._onSocketConnection(e,t)}),this.socketServer.on("error",e=>{this._onSocketError(e)})}_onSocketConnection(e,t){e.on("error",e=>{this._onSocketError(e)});let{searchParams:s}=new URL(t.url??"","https://peerjs"),{id:r,token:i,key:n}=Object.fromEntries(s.entries());if(!r||!i||!n){this._sendErrorAndClose(e,u.INVALID_WS_PARAMETERS);return}if(n!==this.config.key){this._sendErrorAndClose(e,u.INVALID_KEY);return}let o=this.realm.getClientById(r);if(o){if(i!==o.getToken()){e.send(JSON.stringify({type:m.ID_TAKEN,payload:{msg:"ID is taken"}})),e.close();return}this._configureWS(e,o);return}this._registerClient({socket:e,id:r,token:i})}_onSocketError(e){this.emit("error",e)}_registerClient({socket:e,id:t,token:s}){if(this.realm.getClientsIds().length>=this.config.concurrent_limit){this._sendErrorAndClose(e,u.CONNECTION_LIMIT_EXCEED);return}let r=new S({id:t,token:s});this.realm.setClient(r,t),e.send(JSON.stringify({type:m.OPEN})),this._configureWS(e,r)}_configureWS(e,t){t.setSocket(e),e.on("close",()=>{t.getSocket()===e&&(this.realm.removeClientById(t.getId()),this.emit("close",t))}),e.on("message",e=>{try{let s=JSON.parse(e.toString());s.src=t.getId(),this.emit("message",t,s)}catch(e){this.emit("error",e)}}),this.emit("connection",t)}_sendErrorAndClose(e,t){e.send(JSON.stringify({type:m.ERROR,payload:{msg:t}})),e.close()}}let v=e=>{if(e){let t=new Date().getTime();e.setLastPing(t)}return!0},R=({realm:e})=>{let t=(s,r)=>{let i=r.type,n=r.src,o=r.dst,a=e.getClientById(o);if(a){let i=a.getSocket();try{if(i){let e=JSON.stringify(r);i.send(e)}else throw Error("Peer dead")}catch(r){i?i.close():e.removeClientById(a.getId()),t(s,{type:m.LEAVE,src:o,dst:n})}}else![m.LEAVE,m.EXPIRE].includes(i)&&o?e.addMessageToQueue(o,r):i!==m.LEAVE||o||e.removeClientById(n);return!0};return t};class C{registerHandler(e,t){this.handlers.has(e)||this.handlers.set(e,t)}handle(e,t){let{type:s}=t,r=this.handlers.get(s);return!!r&&r(e,t)}constructor(){this.handlers=new Map}}class _{constructor(e,t=new C){this.handlersRegistry=t;let s=R({realm:e}),r=(e,{type:t,src:r,dst:i,payload:n})=>s(e,{type:t,src:r,dst:i,payload:n});this.handlersRegistry.registerHandler(m.HEARTBEAT,(e,t)=>v(e,t)),this.handlersRegistry.registerHandler(m.OFFER,r),this.handlersRegistry.registerHandler(m.ANSWER,r),this.handlersRegistry.registerHandler(m.CANDIDATE,r),this.handlersRegistry.registerHandler(m.LEAVE,r),this.handlersRegistry.registerHandler(m.EXPIRE,r)}handle(e,t){return this.handlersRegistry.handle(e,t)}}var A={};A=JSON.parse('{"name":"PeerJS Server","description":"A server side element to broker connections between PeerJS clients.","website":"https://peerjs.com/"}');var O=({config:e,realm:t})=>{let s=i.Router();return s.get("/id",(s,r)=>{r.contentType("html"),r.send(t.generateClientId(e.generateClientId))}),s.get("/peers",(s,r)=>{if(e.allow_discovery){let e=t.getClientsIds();return r.send(e)}return r.sendStatus(401)}),s};let T=({config:e,realm:t,corsOptions:s})=>{let r=i.Router();return r.use(d(s)),r.get("/",(e,t)=>{var s;t.send((s=A)&&s.__esModule?s.default:s)}),r.use("/:key",O({config:e,realm:t})),r},N=({app:t,server:s,options:r})=>{let i=new I,n=new _(i),o=T({config:r,realm:i,corsOptions:r.corsOptions}),a=new f({realm:i,config:r,messageHandler:n}),l=new E({realm:i,config:r,onClose:e=>{t.emit("disconnect",e)}});t.use(r.path,o);let c=new k({server:s,realm:i,config:{...r,path:e.posix.join(t.path(),r.path,"/")}});c.on("connection",e=>{let s=i.getMessageQueueById(e.getId());if(s){let t;for(;t=s.readMessage();)n.handle(e,t);i.clearMessageQueue(e.getId())}t.emit("connection",e)}),c.on("message",(e,s)=>{t.emit("message",e,s),n.handle(e,s)}),c.on("close",e=>{t.emit("disconnect",e)}),c.on("error",e=>{t.emit("error",e)}),a.startMessagesExpiration(),l.start()},w=s(r(process.argv)),M=!!process.env.PORT,b=w.usage("Usage: $0").wrap(Math.min(98,w.terminalWidth())).options({expire_timeout:{demandOption:!1,alias:"t",describe:"timeout (milliseconds)",default:5e3},concurrent_limit:{demandOption:!1,alias:"c",describe:"concurrent limit",default:5e3},alive_timeout:{demandOption:!1,describe:"broken connection check timeout (milliseconds)",default:6e4},key:{demandOption:!1,alias:"k",describe:"connection key",default:"peerjs"},sslkey:{type:"string",demandOption:!1,describe:"path to SSL key"},sslcert:{type:"string",demandOption:!1,describe:"path to SSL certificate"},host:{type:"string",demandOption:!1,alias:"H",describe:"host"},port:{type:"number",demandOption:!M,alias:"p",describe:"port"},path:{type:"string",demandOption:!1,describe:"custom path",default:process.env.PEERSERVER_PATH??"/"},allow_discovery:{type:"boolean",demandOption:!1,describe:"allow discovery of peers"},proxied:{type:"boolean",demandOption:!1,describe:"Set true if PeerServer stays behind a reverse proxy",default:!1},cors:{type:"string",array:!0,describe:"Set the list of CORS origins"}}).boolean("allow_discovery").parseSync();b.port||(b.port=parseInt(process.env.PORT)),b.cors&&(b.corsOptions={origin:b.cors}),process.on("uncaughtException",function(e){console.error("Error: "+e.toString())}),(b.sslkey??b.sslcert)&&(b.sslkey&&b.sslcert?b.ssl={key:t.readFileSync(e.resolve(b.sslkey)),cert:t.readFileSync(e.resolve(b.sslcert))}:(console.error("Warning: PeerServer will not run because either the key or the certificate has not been provided."),process.exit(1)));let P=b.path,D=function(e={},t){let s;let r=i(),a={...p,...e},l=a.port,c=a.host,{ssl:d,...h}=a;d&&Object.keys(d).length?(s=o.createServer(d,r),a=h):s=n.createServer(r);let g=function(e,t){let s=i(),r={...p,...t};return r.proxied&&s.set("trust proxy","false"!==r.proxied&&!!r.proxied),s.on("mount",()=>{if(!e)throw Error("Server is not passed to constructor - can't start PeerServer");N({app:s,server:e,options:r})}),s}(s,a);return r.use(g),s.listen(l,c,()=>t?.(s)),g}(b,e=>{let{address:t,port:s}=e.address();console.log("Started PeerServer on %s, port: %s, path: %s",t,s,P||"/");let r=()=>{e.close(()=>{console.log("Http server closed."),process.exit(0)})};process.on("SIGINT",r),process.on("SIGTERM",r)});D.on("connection",e=>{console.log(`Client connected: ${e.getId()}`)}),D.on("disconnect",e=>{console.log(`Client disconnected: ${e.getId()}`)});
//# sourceMappingURL=peerjs.js.map
